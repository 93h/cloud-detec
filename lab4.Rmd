---
title: "Lab 4 - Cloud Data, Stat 215A, Fall 2019"
author: 
- "Aya Amanmyradova"
- "Spencer Wilson"
- "Ziyang Zhou"
date: "`r format(Sys.time(), '%B %d, %Y')`"
header-includes:
   - \usepackage{float}
output: 
  pdf_document:
    number_sections: true
editor_options: 
  chunk_output_type: console
---

```{r setup, echo = FALSE, message = FALSE, warning = FALSE}

# load in useful packages
library(tidyverse)
library(ggpubr)
library(mlbench)
library(caret)
library(randomForest)
library("gridExtra")
library("grid")
library("corrplot")

# set default knitr chunks
knitr::opts_chunk$set(
  echo = FALSE,  # don't print the code chunk
  warning = FALSE,  # don't print warnings
  message = FALSE,  # don't print messages
  fig.width = 6,  # set default width of figures
  fig.height = 4,  # set default height of figures
  fig.align = "center",  # align figure in center
  fig.pos = "H",  # plot figure at the exact location of the code chunk
  cache = FALSE)  # don't cache results

```

```{r load}
# Get the data for three images
path <- "data"
image1 <- read.table(paste0('data/', 'image1.txt'), header = F)
image2 <- read.table(paste0('data/', 'image2.txt'), header = F)
image3 <- read.table(paste0('data/', 'image3.txt'), header = F)

# Add informative column names.
collabs <- c('y','x','label','NDAI','SD','CORR','DF','CF','BF','AF','AN')
names(image1) <- collabs
names(image2) <- collabs
names(image3) <- collabs

# combine images into one dataframe
images <- rbind(image1, image2, image3)

## ziyang
images$image <- image
```

# Introduction




# Exploratory Data Analysis

## The Data

The dataset consists of 3 images from the satellite, seen in Figure \ref{fig:labels}. For every pixel, we have x and y coordinates and expert labels (cloud = +1, not cloud = -1, unlabeled = 0), along with 8 other variables: NDAI, SD, CORR, DF, CF, BF, AF and AN. The last 5 variables are radiances obtained from cameras located at different angles. The first 3 measures are features derived from radiances to differentiate surface pixels from cloudy ones. NDAI is a normalized difference angular index that compares mean radiation collected from DF (zenith angle) and AN (nadir direction) cameras. SD is a standard deviation within groups of AN camera radiation measurements, and CORR is an average linear correlation of radiation measurements at different view angles. 

```{r labels,  fig.cap = "Expert labels for the presence or absence of clouds, according to a map.", fig.width=8}

# Plot the expert pixel-level classification of image 1
p1 <- ggplot(image1) + 
  geom_point(aes(x = x, y = y, color = factor(label))) + 
  theme_bw() +
  theme(axis.text = element_text(size = 5),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border= element_blank(),
        legend.text = element_text(size =10),
        legend.title = element_text(size = 15))+
  scale_color_manual(name = "Expert label", 
                     values = c("#3182bd", "#9ecae1", "#deebf7"), 
                     labels = c("Ice", "Unknown", "Clouds"))

# Plot the expert pixel-level classification of image 2
p2 <- ggplot(image2) + 
  geom_point(aes(x = x, y = y, color = factor(label))) + 
  theme_bw() +
  theme(axis.text = element_text(size = 5),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border= element_blank(),
        legend.text = element_text(size =10),
        legend.title = element_text(size = 15))+
  scale_color_manual(name = "Expert label", 
                     values = c("#3182bd", "#9ecae1", "#deebf7"), 
                     labels = c("Ice", "Unknown", "Clouds"))

# Plot the expert pixel-level classification of image 3
p3 <- ggplot(image3) + 
  geom_point(aes(x = x, y = y, color = factor(label))) + 
  theme_bw() +
  theme(axis.text = element_text(size = 5),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border= element_blank(),
        legend.text = element_text(size =10),
        legend.title = element_text(size = 15))+
  scale_color_manual(name = "Expert label", 
                     values = c("#3182bd", "#9ecae1", "#deebf7"), 
                     labels = c("Ice", "Unknown", "Clouds"))

ggarrange(p1, p2, p3, ncol = 3, nrow = 1, common.legend = TRUE) 
```

As we can see from Figure \ref{fig:label_proportion}, image 2 has the most 1-label, while image 3 has the most 0-label (unlabeled), meaning that it contains the most unwanted data. For each image, there are no missing values. The typical IID assumption is broken in this case because the cloud appears in patches. This means that if one pixcel is clssified as cloudy, then the surrounding pixels are also highly likely to be cloudy. This geographic property causes correlation structure among pixels, so we would need to properly compensate for this violation of IID assumtpion in the processing stage.

```{r label_proportion, fig.cap="Proportion of Labels in Each Image"}
## summarizing data
percentage_dat <- images %>%
  group_by(image, label) %>%
  summarise (n = n()) %>%
  mutate(freq = n / sum(n))
  
g1 <- percentage_dat %>%
  filter(image == "img1") %>%
  ggplot(aes(x = label, y = freq)) +
  geom_bar(stat="identity", color="black", fill="lightskyblue3") +
  ylab("Proportion") + 
  ylim(0,0.6) + 
  theme_bw()

g2 <- percentage_dat %>%
  filter(image == "img2") %>%
  ggplot(aes(x = label, y = freq)) +
  geom_bar(stat="identity", color="black", fill="lightskyblue3") +
  ylab("Proportion") +
  ylim(0,0.6) + 
  theme_bw()
  
g3 <- percentage_dat %>%
  filter(image == "img3") %>%
  ggplot(aes(x = label, y = freq)) +
  geom_bar(stat="identity", color="black", fill="lightskyblue3") +
  ylab("Proportion") +
  ylim(0,0.6) + 
  theme_bw()
  
grid.arrange(g1, g2, g3, ncol = 3,
             gp = gpar(fontsize = 16))
```


## The Variables

We explored the relationships between the radiances of different angles both visually and quantitatively. Due to limited report size, we only include scatterplots of the relationship between the radiances DF and CF, CF and BF, BF and AF, and AN and AF (see Figure \ref{fig:scatter}). Radiances from different angles had strong positive correlations for both cloud and non-cloud pixels. However, the correlations were even stronger for non-cloud pixels than cloud pixels. The average correlation between all pairwise radiances ror non-cloud pixels was 0.94, while the average correlation for the cloud pixels was 0.80. These findings agree with the scatterplots. Since the radiances from different angles have strong correlations for both cloud and non-cloud pixels, they can be redundant in modeling the presence of clouds.

```{r corr, results='hide'}

# Correlation matrix of radiances for cloud pixels
corr_cloud <- images %>% 
  filter(label == 1) %>% 
  dplyr::select(DF, CF, BF, AF, AN) %>% 
  cor()
print(corr_cloud)
mean(corr_cloud)
# Correlation matrix of radiances for non-cloud pixels
corr_ice <- images %>% 
  filter(label == -1) %>% 
  dplyr::select(DF, CF, BF, AF, AN) %>% 
  cor()
print(corr_ice)
mean(corr_ice)
# Correlation matrix of NDAI, SD, CORR for cloud pixels
corr2_cloud <- images %>% 
  filter(label == 1) %>% 
  dplyr::select(NDAI, SD, CORR) %>% 
  cor()
print(corr2_cloud)
mean(corr2_cloud)
# Correlation matrix of radiances for non-cloud pixels
corr2_ice <- images %>% 
  filter(label == -1) %>% 
  dplyr::select(NDAI, SD, CORR) %>% 
  cor()
print(corr2_ice)
mean(corr2_ice)
```
```{r scatter, fig.cap = "Scatterplot of radiances.", fig.height=6}

# give labels names
images$lbl <- "Cloud"
images$lbl[images$label == -1] <- "Ice"
images$lbl[images$label == 0] <- "Unknown"

# Convert labels from numeric to factor
images$label <- as.factor(images$label)

# Scatterplots of radiances
p1 <- images %>% 
  filter(label != 0) %>% 
  ggplot() + 
  geom_point(aes(x = DF, y = CF, colour = lbl), size = 0.5, alpha = 0.2) +
  facet_wrap( ~ lbl, ncol=2) + theme(legend.position="none")

p2 <- images %>% 
  filter(label != 0) %>% 
  ggplot() + 
  geom_point(aes(x = CF, y = BF, colour = lbl), size = 0.5, alpha = 0.2) +
  facet_wrap( ~ lbl, ncol=2) + theme(legend.position="none")

p3 <- images %>% 
  filter(label != 0) %>% 
  ggplot() + 
  geom_point(aes(x = BF, y = AF, colour = lbl), size = 0.5, alpha = 0.2) +
  facet_wrap( ~ lbl, ncol=2) + theme(legend.position="none")

p4 <- images %>% 
  filter(label != 0) %>% 
  ggplot() + 
  geom_point(aes(x = AF, y = AN, colour = lbl), size = 0.5, alpha = 0.2) +
  facet_wrap( ~ lbl, ncol=2) + theme(legend.position="none")

ggarrange(p1, p2, p3, p4, ncol = 1, nrow = 4) 
```

We then explored the differences between cloud and non-cloud pixels based on NDAI, CORR, and SD. The pairwise correlations between the features for cloud pixels was 0.53 and for non-cloud ones was 0.62. These values agree with our visual observation from scatterplots (Figure \ref{fig:scatter2}). From the scatterplots, we can observe slight positive relationships between the variables for both the cloud and non-cloud pixels. Although, the relationships are weaker for cloud pixels. In addition, we can see that the variance in CORR and SD gets larger as NDAI increases.

```{r scatter2, fig.cap = "Scatterplot of NDAI, CORR, and SD."}

# Scatterplots of NDAI, CORR, SD
p1 <- images %>% 
  filter(label != 0) %>% 
  ggplot() + 
  geom_point(aes(x = NDAI, y = CORR, colour = lbl), 
             size = 0.75, alpha = 0.2) +
  facet_wrap( ~ lbl, ncol=2) + theme(legend.position="none")

p2 <- images %>% 
  filter(label != 0) %>% 
  ggplot() + 
  geom_point(aes(x = NDAI, y = SD, colour = lbl), 
             size = 0.75, alpha = 0.2) +
  facet_wrap( ~ lbl, ncol=2) + theme(legend.position="none")

p3 <- images %>% 
  filter(label != 0) %>% 
  ggplot() + 
  geom_point(aes(x = CORR, y = SD, colour = lbl), 
             size = 0.75, alpha = 0.2) +
  facet_wrap( ~ lbl, ncol=2) + theme(legend.position="none")

ggarrange(p1, p2, p3, ncol = 1, nrow = 3) 
```

# More EDA

The pair-wise relationship between feature is shown in Figure \ref{fig:corr}. We see that the five angular features, most certainly, are highly correlated with one anohter. Other features are moderately related to each other in either a positive or a negative way but there is no clear pattern of any relationship. To further understand the features, we made a overlaying label distribution plot for each feature in Figure \ref{fig:dist}. We observe that the label distributions are very similar among AF, AN, BF, CF but quite divergent in CORR, log(SD), and NDAI. This is not surpursing since CORR, SD, and NDAI are the features specifically created for this classification task, as mentioned in the original paper Yu (2008). We performed a log-transformation on SD since its original distribution is highly skewed to the right. Most of the distributions here are bell-shaped. Specifically for NDAI, we observe that the distributions for 1-label and -1-label almost have no overlap, and this thus suggests NDAI could be a good predictive featrue in this task.

```{r corr, fig.cap="Correlation Plot among Potential Features"}
## correlation plot
corrplot.mixed(cor(images[,c(-1, -2, -3, -12, -13)]))
```

```{r dist, fig.cap="Overlaying Distribution of Labels among Features"}
## log transformation of SD b/c it is highly skewed
images$logSD <- log(images$SD + 1)

## initial feature definitions
features <- c('NDAI','logSD','CORR','DF','CF','BF','AF','AN')

## distribution plots
images$label <- factor(images$label)
images %>%
  gather(features, 
         key = "Variable", value = "Value") %>%
  ggplot() + 
  geom_density(aes(x = Value, group = label,
                   color = label, fill = label), 
             color = "black", alpha = .7) +
  facet_wrap(Variable ~., 
             scales = "free",
             nrow = 2) +
  theme_bw(base_size = 10) +
  theme(
    plot.title = element_text(size = rel(1.2)),
    axis.title.x = element_text(size = 12, face = "bold"),
    axis.title.y = element_text(size = 12, face = "bold")
  ) + 
  labs(x = "")
```


#  Modeling

## Data Splitting Method

In order to compensate for violation of IID assumption, we suggest other methods of splitting data instead of doing a trivial 80-20 splitting on the entire data set. The first method is to sample based on label, i.e., 80-20 stratified sampling on labels for each image. The reason of doing so is because as Figure \ref{fig:dist} shows, the images are quite different and simply doing a 80-20 splitting on the entire data set would result in unbalanced labels among images. For example, it would be possible that less number of pixels with cloud in image 3 will be sampled becasue of unbalanced labels. The second method we suggest is block sampling, i.e., we divide the image into grids according to $(x,y)$ coordinates and do a 80-20 splitting within each block. Through this method, we would be able to ensure that small patches of clouds will also be captured in training data. In later analysis, we will employ both method and apply those on cross validation. Another possible way of splitting the data accounting their correlation structure is to find the center of clouds, cirle the contours, find the boundaries of each cloud, and sample within/without the boundaries accordingly. Since this share similar characteristics as label splitting, we will thus only implement the first two.

```{r}
## function implementation for label splitting method
label_splits <- function(data){
  res <- list()
  indx <- createDataPartition(data$label, p = 0.8, 
                              list = FALSE, 
                              times = 1)
  res$train <- data[indx, ]
  res$test <-  data[-indx, ]
  return(res)
}

## function implementation for block splitting method
block_splits <- function(nrow, ncol, img){
  res <- list()
  train_data <- data.frame()
  val_data <- data.frame()
  test_data <- data.frame()
  min_y_cor <- min(img$y)
  min_x_cor <- min(img$x)
  max_y_cor <- max(img$y)
  max_x_cor <- max(img$x)
  row_grid <- seq(min_y_cor, 
                  max_y_cor + 1,
                  (max_y_cor + 1 - min_y_cor)/(nrow - 1))
  col_grid <- seq(min_x_cor,
                  max_x_cor + 1,
                  (max_x_cor + 1 - min_x_cor)/(ncol - 1))
  
  for (i in 1:length(row_grid) ){
    for (j in 1:length(col_grid) ){
      img_chunk <- img[img$y >= row_grid[i] & 
                         img$y < row_grid[i + 1] & 
                         img$x >= col_grid[j] & 
                         img$x < col_grid[j + 1], ]
      indx_test <- sample(nrow(img_chunk), 
                          size = floor(nrow(img_chunk) * 0.2))
      test_set <- img_chunk[indx_test, ]
      train_set <- img_chunk[-indx_test_val, ]
      test_data <- rbind(test_data, test_set)
      train_data <- rbind(train_data, train_set)
    }
  }
  
  res$training <- train_data
  res$test <- test_data
  res$row_grid <- row_grid
  res$col_grid <- col_grid
  return(res)
}
```

## Feature Selection

```{r features, eval=FALSE}
# Uncertain expert labels are removed from the dataset 
certain_images <- images %>%
  filter(label != 0) %>%
  mutate(label = as.factor(label))

#Split the data into training and test sets
train <- certain_images %>% sample_frac(0.8)
test <- certain_images %>% anti_join(train)

fit_rf = randomForest(label ~ NDAI + SD + CORR + DF + CF + BF + AF + AN, data = train, importance = TRUE)
fit_rf_limited = randomForest(label ~ NDAI + SD + CORR + AN, data = train, importance = TRUE)

importance(fit_rf)
varImpPlot(fit_rf)
```

```{r boxplots, fig.cap="Boxplots of best predictors."}

# Boxplots for ice and cloud
#NDAI
p1 <- images %>% 
  filter(label != 0) %>% 
  ggplot(aes(x = lbl, y = NDAI)) + 
  geom_boxplot() + xlab("Label")

#SD
p2 <- images %>% 
  filter(label != 0) %>% 
  ggplot(aes(x = lbl, y = SD)) + 
  geom_boxplot() + xlab("Label")

#CORR
p3 <- images %>% 
  filter(label != 0) %>% 
  ggplot(aes(x = lbl, y = CORR)) + 
  geom_boxplot() + xlab("Label")

ggarrange(p1, p2, p3, ncol = 3, nrow = 1)
```

```{r boxplots-all, fig.cap="Boxplot Distribution of Labels among Features"}
images %>%
  filter(label != 0) %>%
  gather(features,
         key = "Variable", value = "Value") %>%
  ggplot() + 
  geom_boxplot(aes(x = label, 
                   y = Value,
                   color= label)) + 
  facet_wrap(Variable ~., 
             scales = "free",
             nrow = 2) +
  theme_bw(base_size = 10) +
  theme(
    plot.title = element_text(size = rel(1.2)),
    axis.title.x = element_text(size = 12, face = "bold"),
    axis.title.y = element_text(size = 12, face = "bold")
  ) + 
  labs(x = "") 
```


## Description and Assumptions of Classifiers

## Assessment of fit of Classifiers

## The Best Classifier

## Post-hoc EDA

# Conclusion










# ziyang

# Heuristics EDA
```{r}
## summarizing data
percentage_dat <- images %>%
  group_by(image, label) %>%
  summarise (n = n()) %>%
  mutate(freq = n / sum(n))
  
g1 <- percentage_dat %>%
  filter(image == "img1") %>%
  ggplot(aes(x = label, y = freq)) +
  geom_bar(stat="identity", color="black", fill="lightskyblue3")+
  ylab("Proportion")+
  ylim(0,0.6)

g2 <- percentage_dat %>%
  filter(image == "img2") %>%
  ggplot(aes(x = label, y = freq)) +
  geom_bar(stat="identity", color="black", fill="lightskyblue3")+
  ylab("Proportion")+
  ylim(0,0.6) 
  
g3 <- percentage_dat %>%
  filter(image == "img3") %>%
  ggplot(aes(x = label, y = freq)) +
  geom_bar(stat="identity", color="black", fill="lightskyblue3")+
  ylab("Proportion")+
  ylim(0,0.6) 

grid.arrange(g1, g2, g3, ncol = 3,
             top = textGrob("Proportion of label in each image",
                            gp = gpar(fontsize = 16))) 

## 1 different pattern of cloudiness
## 2 histograms are different across images
## 3 iid assumptions ?
```

```{r}
## correlation plot
corrplot.mixed(cor(images[,c(-3, -12, -13)]))

## discussions
## 1 high positive correlation between five angular features, which
## is consistent with the linear plot (keep one?)
## 2 low positive correlation for NDAI, CORR, and SD.

## distribution plot - density
images$logSD <- log(images$SD + 1)
features <- c('NDAI','logSD','CORR','DF','CF','BF','AF','AN')
images %>%
  filter(label != 0) %>%
  gather(features, 
         key = "Variable", value = "Value") %>%
  ggplot() + 
  geom_density(aes(x = Value, group = label,
                   color = label, fill = label), 
             color = "black", alpha = .7) +
  facet_wrap(Variable ~., 
             scales = "free",
             nrow = 2) +
  theme_bw(base_size = 10) +
  theme(
    plot.title = element_text(size = rel(1.2)),
    axis.title.x = element_text(size = 12, face = "bold"),
    axis.title.y = element_text(size = 12, face = "bold")
  ) + 
  labs(x = "") +
  ggtitle("Overlaying Distribution of Labels among Features")

## discussions
## 1 similar label distribution among CF, BF, AF, AN and DF
## 2 quite divergent label distribution among CORR, SD, and NDAI
## 3 NDAI could be good feature in terms of binary classification for 
## labels -1 and 1

## distribution plot - boxplot
images %>%
  filter(label != 0) %>%
  gather(features,
         key = "Variable", value = "Value") %>%
  ggplot() + 
  geom_boxplot(aes(x = label, 
                   y = Value,
                   color= label)) + 
  facet_wrap(Variable ~., 
             scales = "free",
             nrow = 2) +
  theme_bw(base_size = 10) +
  theme(
    plot.title = element_text(size = rel(1.2)),
    axis.title.x = element_text(size = 12, face = "bold"),
    axis.title.y = element_text(size = 12, face = "bold")
  ) + 
  labs(x = "") +
  ggtitle("Boxplot Distribution of Labels among Features")

## discussions
## more variation -> better feature
```


# Heuristics Data Splitting

## trivial partition

```{r}
trivial_splits <- function(data){
  res <- list()
  indx <- sample(nrow(data), size = nrow(data)*0.8)
  res$train <- data[indx, ]
  res$test <- data[-indx, ]
  return(res)
}
```


## partition by labels (outcome splits)

```{r}
label_splits <- function(data){
  res <- list()
  indx <- createDataPartition(data$label, p = .8, 
                                  list = FALSE, 
                                  times = 1)
  res$train <- data[indx, ]
  res$test <-  data[-indx, ]
  return(res)
}
```

## partition by blocks (image block splits)

```{r}
block_splits <- function(nrow, ncol, img){
  res <- list()
  train_data <- data.frame()
  val_data <- data.frame()
  test_data <- data.frame()
  min_y_cor <- min(img$y)
  min_x_cor <- min(img$x)
  max_y_cor <- max(img$y)
  max_x_cor <- max(img$x)
  row_grid <- seq(min_y_cor, 
                    max_y_cor + 1,
                    (max_y_cor + 1 - min_y_cor)/(nrow - 1))
  col_grid <- seq(min_x_cor,
                    max_x_cor + 1,
                    (max_x_cor + 1 - min_x_cor)/(ncol - 1))
  
  for (i in 1:length(row_grid) ){
    for (j in 1:length(col_grid) ){
      img_chunk <- img[img$y >= row_grid[i] & 
                         img$y < row_grid[i + 1] & 
                         img$x >= col_grid[j] & 
                         img$x < col_grid[j + 1], ]
      indx_test_val <- sample(nrow(img_chunk), 
                                 size = floor(nrow(img_chunk) * 0.4))
      indx_val <- sample(indx_test_val,
                         size = floor(length(indx_test_val)/2))
      indx_test <- indx_test_val[!indx_test_val %in% indx_val]
      test_set <- img_chunk[indx_test, ]
      val_set <- img_chunk[indx_val, ]
      train_set <- img_chunk[-indx_test_val, ]
      train_data <- rbind(train_data, train_set)
      test_data <- rbind(test_data, test_set)
      val_data <- rbind(val_data, val_set)
    }
  }
  
  res$training <- train_data
  res$validation <- val_data
  res$test <- test_data
  res$row_grid <- row_grid
  res$col_grid <- col_grid
  return(res)
}

image1 <- image1 %>% filter(label != 0)
image2 <- image2 %>% filter(label != 0)
image3 <- image3 %>% filter(label != 0)
naive_split_result_1 <- trivial_splits(image1)
label_split_result_1 <- label_splits(image1)
block_split_result_1 <- block_splits(10,10,image1)
naive_split_result_2 <- trivial_splits(image2)
label_split_result_2 <- label_splits(image2)
block_split_result_2 <- block_splits(10,10,image2)
naive_split_result_3 <- trivial_splits(image3)
label_split_result_3 <- label_splits(image3)
block_split_result_3 <- block_splits(10,10,image3)

x_cord1 <- block_split_result_1$col_grid
y_cord1 <- block_split_result_1$row_grid
x_cord2 <- block_split_result_2$col_grid
y_cord2 <- block_split_result_2$row_grid
x_cord3 <- block_split_result_3$col_grid
y_cord3 <- block_split_result_3$row_grid

img1 <- ggplot(image1) + 
  geom_point(aes(x = x, y = y, color = factor(label))) + 
  theme_bw() +
  theme(axis.text = element_text(size = 5),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border= element_blank(),
        legend.text = element_text(size =10),
        legend.title = element_text(size = 15))+
  scale_color_manual(name = "Expert label", 
                     values = c("#3182bd", "#deebf7"), 
                     labels = c("Ice", "Clouds")) +
  geom_vline(xintercept = x_cord1, linetype = "dashed") + 
  geom_hline(yintercept = y_cord1, linetype = "dashed") + 
  ggtitle("original image1")

block1 <- block_split_result_1$training %>%
ggplot() + 
  geom_point(aes(x = x, y = y, color = factor(label))) + 
  theme_bw() +
  theme(axis.text = element_text(size = 5),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border= element_blank(),
        legend.text = element_text(size =10),
        legend.title = element_text(size = 15))+
  scale_color_manual(name = "Expert label", 
                     values = c("#3182bd", "#deebf7"), 
                     labels = c("Ice", "Clouds")) +
  geom_vline(xintercept = x_cord1, linetype = "dashed") + 
  geom_hline(yintercept = y_cord1, linetype = "dashed") +
  ggtitle("image1 blocking splits")

naive1 <- naive_split_result_1$train %>%
  ggplot() + 
  geom_point(aes(x = x, y = y, color = factor(label))) + 
  theme_bw() +
  theme(axis.text = element_text(size = 5),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border= element_blank(),
          legend.text = element_text(size =10),
          legend.title = element_text(size = 15))+
  scale_color_manual(name = "Expert label", 
                     values = c("#3182bd", "#deebf7"), 
                     labels = c("Ice", "Clouds")) +
  geom_vline(xintercept = x_cord1, linetype = "dashed") + 
  geom_hline(yintercept = y_cord1, linetype = "dashed") + 
  ggtitle("image1 trivial splits")


label1 <- label_split_result_1$train %>%
  ggplot() + 
  geom_point(aes(x = x, y = y, color = factor(label))) + 
  theme_bw() +
  theme(axis.text = element_text(size = 5),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border= element_blank(),
          legend.text = element_text(size =10),
          legend.title = element_text(size = 15))+
  scale_color_manual(name = "Expert label", 
                     values = c("#3182bd", "#deebf7"), 
                     labels = c("Ice", "Clouds")) +
  geom_vline(xintercept = x_cord1, linetype = "dashed") + 
  geom_hline(yintercept = y_cord1, linetype = "dashed") +
  ggtitle("image1 label splits")

#grid.arrange(img1, naive1, block1, label1, ncol = 2)

img2 <- ggplot(image2) + 
  geom_point(aes(x = x, y = y, color = factor(label))) + 
  theme_bw() +
  theme(axis.text = element_text(size = 5),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border= element_blank(),
        legend.text = element_text(size =10),
        legend.title = element_text(size = 15))+
  scale_color_manual(name = "Expert label", 
                     values = c("#3182bd", "#deebf7"), 
                     labels = c("Ice", "Clouds")) +
  geom_vline(xintercept = x_cord2, linetype = "dashed") + 
  geom_hline(yintercept = y_cord2, linetype = "dashed") + 
  ggtitle("original image2")

block2 <- block_split_result_2$training %>%
ggplot() + 
  geom_point(aes(x = x, y = y, color = factor(label))) + 
  theme_bw() +
  theme(axis.text = element_text(size = 5),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border= element_blank(),
        legend.text = element_text(size =10),
        legend.title = element_text(size = 15))+
  scale_color_manual(name = "Expert label", 
                     values = c("#3182bd", "#deebf7"), 
                     labels = c("Ice", "Clouds")) +
  geom_vline(xintercept = x_cord2, linetype = "dashed") + 
  geom_hline(yintercept = y_cord2, linetype = "dashed") +
  ggtitle("image2 blocking splits")

naive2 <- naive_split_result_2$train %>%
  ggplot() + 
  geom_point(aes(x = x, y = y, color = factor(label))) + 
  theme_bw() +
  theme(axis.text = element_text(size = 5),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border= element_blank(),
          legend.text = element_text(size =10),
          legend.title = element_text(size = 15))+
  scale_color_manual(name = "Expert label", 
                     values = c("#3182bd", "#deebf7"), 
                     labels = c("Ice", "Clouds")) +
  geom_vline(xintercept = x_cord2, linetype = "dashed") + 
  geom_hline(yintercept = y_cord2, linetype = "dashed") + 
  ggtitle("image2 trivial splits")


label2 <- label_split_result_2$train %>%
  ggplot() + 
  geom_point(aes(x = x, y = y, color = factor(label))) + 
  theme_bw() +
  theme(axis.text = element_text(size = 5),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border= element_blank(),
          legend.text = element_text(size =10),
          legend.title = element_text(size = 15))+
  scale_color_manual(name = "Expert label", 
                     values = c("#3182bd", "#deebf7"), 
                     labels = c("Ice", "Clouds")) +
  geom_vline(xintercept = x_cord2, linetype = "dashed") + 
  geom_hline(yintercept = y_cord2, linetype = "dashed") +
  ggtitle("image2 label splits")

#grid.arrange(img2, naive2, block2, label2, ncol = 2)

img3 <- ggplot(image3) + 
  geom_point(aes(x = x, y = y, color = factor(label))) + 
  theme_bw() +
  theme(axis.text = element_text(size = 5),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border= element_blank(),
        legend.text = element_text(size =10),
        legend.title = element_text(size = 15))+
  scale_color_manual(name = "Expert label", 
                     values = c("#3182bd", "#deebf7"), 
                     labels = c("Ice", "Clouds")) +
  geom_vline(xintercept = x_cord3, linetype = "dashed") + 
  geom_hline(yintercept = y_cord3, linetype = "dashed") + 
  ggtitle("original image3")

block3 <- block_split_result_3$training %>%
ggplot() + 
  geom_point(aes(x = x, y = y, color = factor(label))) + 
  theme_bw() +
  theme(axis.text = element_text(size = 5),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border= element_blank(),
        legend.text = element_text(size =10),
        legend.title = element_text(size = 15))+
  scale_color_manual(name = "Expert label", 
                     values = c("#3182bd", "#deebf7"), 
                     labels = c("Ice", "Clouds")) +
  geom_vline(xintercept = x_cord3, linetype = "dashed") + 
  geom_hline(yintercept = y_cord3, linetype = "dashed") +
  ggtitle("image3 blocking splits")

naive3 <- naive_split_result_3$train %>%
  ggplot() + 
  geom_point(aes(x = x, y = y, color = factor(label))) + 
  theme_bw() +
  theme(axis.text = element_text(size = 5),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border= element_blank(),
          legend.text = element_text(size =10),
          legend.title = element_text(size = 15))+
  scale_color_manual(name = "Expert label", 
                     values = c("#3182bd", "#deebf7"), 
                     labels = c("Ice", "Clouds")) +
  geom_vline(xintercept = x_cord3, linetype = "dashed") + 
  geom_hline(yintercept = y_cord3, linetype = "dashed") + 
  ggtitle("image3 trivial splits")


label3 <- label_split_result_3$train %>%
  ggplot() + 
  geom_point(aes(x = x, y = y, color = factor(label))) + 
  theme_bw() +
  theme(axis.text = element_text(size = 5),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border= element_blank(),
          legend.text = element_text(size =10),
          legend.title = element_text(size = 15))+
  scale_color_manual(name = "Expert label", 
                     values = c("#3182bd", "#deebf7"), 
                     labels = c("Ice", "Clouds")) +
  geom_vline(xintercept = x_cord3, linetype = "dashed") + 
  geom_hline(yintercept = y_cord3, linetype = "dashed") +
  ggtitle("image1 label splits")

#grid.arrange(img3, naive3, block3, label3, ncol = 2)

grid.arrange(img1, naive1, block1, label1,
             img2, naive2, block2, label2,
             img3, naive3, block3, label3, ncol = 4)
```

